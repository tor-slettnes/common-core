/// -*- c++ -*-
//==============================================================================
/// @file convert.i++
/// @brief String conversions - inline definitions
/// @author Tor Slettnes <tor@slett.net>
//==============================================================================

namespace shared::str
{
    //==========================================================================
    // StringConvert<T>

    template <class T>
    inline T StringConvert<T>::from_string(const std::string &s)
    {
        const static std::regex _rx_hexprefix("0x[[:xdigit:]]+",
                                              std::regex_constants::icase);

        std::istringstream ss(s);
        if (std::regex_match(s, _rx_hexprefix))
        {
            ss >> std::hex;
        }

        T value;
        ss >> value;
        checkstream(ss, s, typeid(T));
        return value;
    }

    // template <class T, std::enable_if_t<!std::is_integral_v<T>, bool> = true>
    // inline T StringConvert<T>::from_string(const std::string &s)
    // {
    //     std::istringstream ss(s);
    //     T value;
    //     ss >> value;
    //     checkstream(ss, s, typeid(T));
    //     return value;
    // }

    template <class T>
    inline std::string StringConvert<T>::to_string(const T &value)
    {
        std::ostringstream ss;
        ss << value;
        return ss.str();
    }

    inline std::string StringConvert<std::string>::from_string(const std::string &s)
    {
        return s;
    }

    inline std::string StringConvert<std::string>::to_string(const std::string &s)
    {
        return s;
    }

    inline bool StringConvert<bool>::from_string(const std::string &s)
    {
        return str::to_bool(s);
    }

    inline std::string StringConvert<bool>::to_string(const bool &value)
    {
        std::ostringstream ss;
        ss << std::boolalpha << value;
        return ss.str();
    }

    //==========================================================================
    // Wrapper methods

    template <class T>
    T convert_to(const std::string &s)
    {
        return StringConvert<T>::from_string(s);
    }

    template <class T>
    T convert_to(const std::string &s,
                 const T &fallback,
                 std::exception_ptr *eptr) noexcept
    {
        try
        {
            return convert_to<T>(s);
        }
        catch (...)
        {
            if (eptr)
            {
                *eptr = std::current_exception();
            }
            return fallback;
        }
    }

    template <class T>
    std::string convert_from(const T &value) noexcept
    {
        return StringConvert<T>::to_string(value);
    }
}  // namespace shared::str

namespace std
{
    template <class T1, class T2>
    std::ostream &operator<<(std::ostream &stream, const std::pair<T1, T2> &pair)
    {
        shared::str::format(stream, "{%r, %r}", pair.first, pair.second);
        return stream;
    }

    template <class T>
    std::ostream &operator<<(std::ostream &stream, const std::vector<T> &vector)
    {
        stream << "{";
        std::string sep = "";
        for (const T &element : vector)
        {
            shared::str::format(stream, "%s%r", sep, element);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class K, class V>
    std::ostream &operator<<(std::ostream &stream, const std::map<K, V> &map)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &[key, value] : map)
        {
            shared::str::format(stream, "%s%r: %r", sep, key, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class K, class V>
    std::ostream &operator<<(std::ostream &stream, const std::unordered_map<K, V> &map)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &[key, value] : map)
        {
            shared::str::format(stream, "%s%r: %r", sep, key, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::set<V> &set)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &value : set)
        {
            shared::str::format(stream, "%s%r", sep, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::unordered_set<V> &set)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &value : set)
        {
            shared::str::format(stream, "%s%r", sep, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class K, class V>
    std::ostream &operator<<(std::ostream &stream, const std::multimap<K, V> &map)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &[key, value] : map)
        {
            shared::str::format(stream, "%s%r: %r", sep, key, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class K, class V>
    std::ostream &operator<<(std::ostream &stream, const std::unordered_multimap<K, V> &map)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &[key, value] : map)
        {
            shared::str::format(stream, "%s%r: %r", sep, key, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::multiset<V> &set)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &value : set)
        {
            shared::str::format(stream, "%s%r", sep, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::unordered_multiset<V> &set)
    {
        stream << "{";
        std::string sep = "";
        for (const auto &value : set)
        {
            shared::str::format(stream, "%s%r", sep, value);
            sep = ", ";
        }
        stream << "}";
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::optional<V> &opt)
    {
        if (opt.has_value())
        {
            shared::str::format(stream, "{%r}", opt.value());
        }
        else
        {
            stream << "{}";
        }
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::shared_ptr<V> &ptr)
    {
        if (ptr)
        {
            shared::str::format(stream, "{%r}", *ptr);
        }
        else
        {
            stream << "{}";
        }
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::unique_ptr<V> &ptr)
    {
        if (ptr)
        {
            shared::str::format(stream, "{%r}", *ptr);
        }
        else
        {
            stream << "{}";
        }
        return stream;
    }

    template <class V>
    std::ostream &operator<<(std::ostream &stream, const std::weak_ptr<V> &weakptr)
    {
        if (auto sptr = weakptr.lock())
        {
            shared::str::format(stream, "{%r}", *sptr);
        }
        else
        {
            stream << "{}";
        }
        return stream;
    }

}  // namespace std
