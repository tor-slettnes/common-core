/// -*- c++ -*-
//==============================================================================
/// @file convert.i++
/// @brief String conversions - inline definitions
/// @author Tor Slettnes <tor@slett.net>
//==============================================================================

namespace shared::str
{
    //==========================================================================
    // StringConvert<T>

    template <class T>
    inline T StringConvert<T>::from_string(const std::string &s)
    {
        const static std::regex _rx_hexprefix("0x[[:xdigit:]]+",
                                              std::regex_constants::icase);

        std::istringstream ss(s);
        if (std::regex_match(s, _rx_hexprefix))
        {
            ss >> std::hex;
        }

        T value;
        ss >> value;
        checkstream(ss, s, typeid(T));
        return value;
    }

    // template <class T, std::enable_if_t<!std::is_integral_v<T>, bool> = true>
    // inline T StringConvert<T>::from_string(const std::string &s)
    // {
    //     std::istringstream ss(s);
    //     T value;
    //     ss >> value;
    //     checkstream(ss, s, typeid(T));
    //     return value;
    // }

    template <class T>
    inline std::string StringConvert<T>::to_string(const T &value)
    {
        std::ostringstream ss;
        ss << value;
        return ss.str();
    }

    inline std::string StringConvert<std::string>::from_string(const std::string &s)
    {
        return s;
    }

    inline std::string StringConvert<std::string>::to_string(const std::string &s)
    {
        return s;
    }

    inline bool StringConvert<bool>::from_string(const std::string &s)
    {
        return str::to_bool(s);
    }

    inline std::string StringConvert<bool>::to_string(const bool &value)
    {
        std::ostringstream ss;
        ss << std::boolalpha << value;
        return ss.str();
    }

    //==========================================================================
    // Wrapper methods

    template <class T>
    T convert_to(const std::string &s)
    {
        return StringConvert<T>::from_string(s);
    }

    template <class T>
    T convert_to(const std::string &s,
                 const T &fallback,
                 std::exception_ptr *eptr) noexcept
    {
        try
        {
            return convert_to<T>(s);
        }
        catch (...)
        {
            if (eptr)
            {
                *eptr = std::current_exception();
            }
            return fallback;
        }
    }

    template <class T>
    std::string convert_from(const T &value) noexcept
    {
        return StringConvert<T>::to_string(value);
    }
}  // namespace shared::str

