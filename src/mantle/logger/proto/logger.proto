// -*- Protocol-Buffers -*-
//==============================================================================
/// @file logging.proto
/// @brief Logging interface
/// @author Tor Slettnes <tor@slett.net>
//==============================================================================

syntax = "proto3";

package cc.logger;

import "status.proto";
import "variant.proto";
import "datetime.proto";
import "google/protobuf/empty.proto";

service Logger
{
    // Log a single message
    rpc log (cc.status.Event) returns (google.protobuf.Empty);

    // Open a writable stream for continuous logging
    rpc writer (stream cc.status.Event) returns (google.protobuf.Empty);

    // Open a readable stream for continuous monitoring.  A new log sink is
    // created on the server side to capture events on behalf of the client.
    rpc listen (ListenerSpec) returns (stream cc.status.Event);

    // Add a new log sink to capture events meeting the specified criteria.
    rpc add_sink (SinkSpec) returns (AddSinkResult);

    // Delete an existing data contract.  This may remove corresponding log
    // sinks.
    rpc remove_sink (SinkID) returns (RemoveSinkResult);

    // Return definition for a single log sink
    rpc get_sink (SinkID) returns (SinkSpec);

    // Return defintions for all available log sinks
    rpc list_sinks (google.protobuf.Empty) returns (SinkSpecs);

    // Return a list of keys corresponding to fixed (always available) fields in
    // log events - i.e. the static field names from the `cc.status.Event`
    // message. These can be included alongside custom attributes as
    // `contract_fields` when adding a sink.
    rpc list_static_fields (google.protobuf.Empty) returns (FieldNames);

}


//==============================================================================
// Types related to log sinks

message SinkID
{
    string sink_id = 1;
}

message SinkSpecs
{
    repeated SinkSpec specs = 1;
}

message SinkSpec
{
    // Unique name for this sink
    string sink_id = 1;

    // Sink type
    SinkType sink_type = 2;

    // Whether this sink should be added permanently (saved to config)
    bool persistent = 3;

    // Filename template, used by log sinks that write directly to files.  If
    // not provided, defaults to `{sink_id}` followed by enough date/time fields
    // to ensure a new output file at every rotation interval.
    //
    // If no suffix is provided, one is added according to `sink_type`: `.log`,
    // `.json`, `.csv`, `.db`.
    //
    // The following placeholders are expanded
    //   - '{executable}` : then name of the log server executable
    //   - `{sink_id}`    : the name of the log sink
    //   - `{isodate}`    : date formatted as "YYYY-MM-DD"
    //   - `{isotime}`    : time of day formatted as "HH:MM:SS"
    //   - `{year}`       : four-digit year
    //   - `{month}`      : two-digit month (01 - 12)
    //   - `{day}`        : two-digit day (01 - 31)
    //   - `{hour}`       : two-digit hour (00 - 23)
    //   - `{minute}`     : two-digit minute (00 - 59)
    //   - `{second}`     : two-digit second (00 - 61)
    //   - `{zonename}`   : time zone name or abbreviation (e.g., "PST")
    //   - `{zoneoffset}` : time zone offset (e.g. "-0700")
    //
    // The timestamp is the current time aligned according to the last nominal
    // rotation time, given `rotation_interval` above.  For instance, given a
    // six-hour rotation interval the timestamps would be truncated to 00:00,
    // 06:00, 12:00, and 18:00, local time.
    string filename_template = 4;

    // How frequently to rotate/switch log files.
    // If not provided, daily rotation is assumed.
    cc.datetime.Interval rotation_interval = 5;

    // Use local time rather than UTC for filename expansions, file rotations
    // and printable timestamps within log. Defaults to `true` if unspecified.
    optional bool use_local_time = 6;

    // Minimum severity level to capture
    cc.status.Level min_level = 8;

    // Specific log contract, if any.  Only events with matching `contract_id`
    // will be captured.
    optional string contract_id = 10;

    // What fields from matching events to include in log. These may be:
    //
    //   - static fields (corresponding to fields in the `cc.status.Event`
    //     ProtoBuf message; use `list_static_fields()` to get a list.
    //
    //   - dynamic fields assumed to be present in log events with a matching
    //     `contract_id`.
    //
    // Each variant `Value` in the `fields` list is interpreted as follows:
    //
    // * `tag` denotes a field name, expected to be present as attributes in log
    //   events with a matching `contract_id`.  This is required for `CSV` and
    //   `DB` sinks.
    //
    // * The `oneof value` seletor and the corresponding `value_*` field
    //   implicitly denotes the type of event field, along with the default
    //   value to log if the field is not present in a message.  This is
    //   required for `DB` sinks, but may omitted for static fields.
    cc.variant.ValueList fields = 11;
}

enum SinkType
{
    SINKTYPE_UNSPECIFIED = 0;   // Unknown/no type
    SINKTYPE_SYSLOG = 1;        // OS-specific text based system/event log
    SINKTYPE_LOGFILE  = 2;      // Plaintext log file
    SINKTYPE_JSON = 3;          // JSON file with (possibly nested) data fields
    SINKTYPE_CSV = 4;           // Comma-separated values, fixed data fields
    SINKTYPE_DB = 5;            // Database with fixed fields
}

message AddSinkResult
{
    bool added = 1;
}

message RemoveSinkResult
{
    bool removed = 1;
}


message FieldNames
{
    repeated string field_names = 1;
}


//==============================================================================
// Types related to listeners

message ListenerSpec
{
    // ID to use when creating a log sink on the server side.
    // If not provided, the client address is used.
    string sink_id = 1;

    // Event stream: Minimum severity / logging level
    cc.status.Level min_level = 8;

    // Data stream: contract/schema ID
    optional string contract_id = 10;
}
